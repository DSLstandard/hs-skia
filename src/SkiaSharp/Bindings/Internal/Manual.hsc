module SkiaSharp.Bindings.Internal.Manual where

import qualified Language.C.Inline as C

import Foreign
import SkiaSharp.Bindings.Internal.AutoGenerated

C.include "<c/gr_context.h>"
C.include "<c/sk_bitmap.h>"
C.include "<c/sk_blender.h>"
C.include "<c/sk_canvas.h>"
C.include "<c/sk_codec.h>"
C.include "<c/sk_colorfilter.h>"
C.include "<c/sk_colorspace.h>"
C.include "<c/sk_data.h>"
C.include "<c/sk_document.h>"
C.include "<c/sk_drawable.h>"
C.include "<c/sk_font.h>"
C.include "<c/sk_general.h>"
C.include "<c/sk_graphics.h>"
C.include "<c/sk_image.h>"
C.include "<c/sk_imagefilter.h>"
C.include "<c/sk_linker.h>"
C.include "<c/sk_maskfilter.h>"
C.include "<c/sk_matrix.h>"
C.include "<c/sk_paint.h>"
C.include "<c/sk_path.h>"
C.include "<c/sk_patheffect.h>"
C.include "<c/sk_picture.h>"
C.include "<c/sk_pixmap.h>"
C.include "<c/sk_region.h>"
C.include "<c/sk_rrect.h>"
C.include "<c/sk_runtimeeffect.h>"
C.include "<c/sk_shader.h>"
C.include "<c/sk_stream.h>"
C.include "<c/sk_string.h>"
C.include "<c/sk_surface.h>"
C.include "<c/sk_svg.h>"
C.include "<c/sk_textblob.h>"
C.include "<c/sk_typeface.h>"
C.include "<c/sk_types.h>"
C.include "<c/sk_vertices.h>"
C.include "<c/skottie_animation.h>"
C.include "<c/skresources_resource_provider.h>"
C.include "<c/sksg_invalidation_controller.h>"

-- TODO: Learn how to use inline-c properly for passing C structure values.

-- | `gr_direct_context_make_direct3d`
grDirectContextMakeDirect3d :: GrD3dBackendContext -> IO (Ptr GrDirectContext)
grDirectContextMakeDirect3d ctx = do
    let adapter = castPtr ctx.adapter
    let device = castPtr ctx.device
    let queue = castPtr ctx.queue
    let memoryAllocator = castPtr ctx.memoryAllocator
    let protectedContext = ctx.protectedContext

    ptr <- [C.block|void* {
        gr_d3d_backendcontext_t in;
        in.fAdapter = $(void* adapter);
        in.fDevice = $(void* device);
        in.fQueue = $(void* queue);
        in.fMemoryAllocator = $(void* memoryAllocator);
        in.fProtectedContext = $(bool protectedContext);

        return gr_direct_context_make_direct3d(in);
    }|]
    pure (castPtr ptr)

-- | `gr_direct_context_make_direct3d_with_options`
grDirectContextMakeDirect3dWithOptions :: GrD3dBackendContext -> Ptr GrContextOptions -> IO (Ptr GrDirectContext)
grDirectContextMakeDirect3dWithOptions ctx inOptions = do
    let adapter = castPtr ctx.adapter
    let device = castPtr ctx.device
    let queue = castPtr ctx.queue
    let memoryAllocator = castPtr ctx.memoryAllocator
    let protectedContext = ctx.protectedContext

    let options = castPtr inOptions

    ptr <- [C.block|void* {
        gr_d3d_backendcontext_t in;
        in.fAdapter = $(void* adapter);
        in.fDevice = $(void* device);
        in.fQueue = $(void* queue);
        in.fMemoryAllocator = $(void* memoryAllocator);
        in.fProtectedContext = $(bool protectedContext);

        return gr_direct_context_make_direct3d_with_options(in, $(void* options));
    }|]
    pure (castPtr ptr)

-- | `gr_direct_context_make_vulkan`
grDirectContextMakeVulkan :: GrVkBackendContext -> IO (Ptr GrDirectContext)
grDirectContextMakeVulkan ctx = do
    let instancePtr' = castPtr ctx.instance_
    let physicalDevice' = castPtr ctx.physicalDevice
    let device' = castPtr ctx.device
    let queue' = castPtr ctx.queue
    let graphicsQueueIndex' = ctx.graphicsQueueIndex
    let minAPIVersion' = ctx.minAPIVersion
    let instanceVersion' = ctx.instanceVersion
    let maxAPIVersion' = ctx.maxAPIVersion
    let extensions' = ctx.extensions
    let vkExtensions' = castPtr ctx.vkExtensions
    let features' = ctx.features
    let deviceFeatures' = castPtr ctx.deviceFeatures
    let deviceFeatures2' = castPtr ctx.deviceFeatures2
    let memoryAllocator' = castPtr ctx.memoryAllocator
    let getProc' :: Ptr () = castFunPtrToPtr ctx.getProc
    let getProcUserData' = castPtr ctx.getProcUserData
    let ownsInstanceAndDevice' = ctx.ownsInstanceAndDevice
    let protectedContext' = ctx.protectedContext

    ptr <- [C.block|void* {
        gr_vk_backendcontext_t in;
        in.fInstance = $(void* instancePtr');
        in.fPhysicalDevice = $(void* physicalDevice');
        in.fDevice = $(void* device');
        in.fQueue = $(void* queue');
        in.fGraphicsQueueIndex = $(uint32_t graphicsQueueIndex');
        in.fMinAPIVersion = $(uint32_t minAPIVersion');
        in.fInstanceVersion = $(uint32_t instanceVersion');
        in.fMaxAPIVersion = $(uint32_t maxAPIVersion');
        in.fExtensions = $(uint32_t extensions');
        in.fVkExtensions = $(void* vkExtensions');
        in.fFeatures = $(uint32_t features');
        in.fDeviceFeatures = $(void* deviceFeatures');
        in.fDeviceFeatures2 = $(void* deviceFeatures2');
        in.fMemoryAllocator = $(void* memoryAllocator');
        in.fGetProc = $(void* getProc');
        in.fGetProcUserData = $(void* getProcUserData');
        in.fOwnsInstanceAndDevice = $(bool ownsInstanceAndDevice');
        in.fProtectedContext = $(bool protectedContext');

        return gr_direct_context_make_vulkan(in);
    }|]
    pure (castPtr ptr)

-- | `gr_direct_context_make_vulkan_with_options`
grDirectContextMakeVulkanWithOptions :: GrVkBackendContext -> Ptr GrContextOptions -> IO (Ptr GrDirectContext)
grDirectContextMakeVulkanWithOptions ctx inOptions = do
    let instancePtr' = castPtr ctx.instance_
    let physicalDevice' = castPtr ctx.physicalDevice
    let device' = castPtr ctx.device
    let queue' = castPtr ctx.queue
    let graphicsQueueIndex' = ctx.graphicsQueueIndex
    let minAPIVersion' = ctx.minAPIVersion
    let instanceVersion' = ctx.instanceVersion
    let maxAPIVersion' = ctx.maxAPIVersion
    let extensions' = ctx.extensions
    let vkExtensions' = castPtr ctx.vkExtensions
    let features' = ctx.features
    let deviceFeatures' = castPtr ctx.deviceFeatures
    let deviceFeatures2' = castPtr ctx.deviceFeatures2
    let memoryAllocator' = castPtr ctx.memoryAllocator
    let getProc' :: Ptr () = castFunPtrToPtr ctx.getProc
    let getProcUserData' = castPtr ctx.getProcUserData
    let ownsInstanceAndDevice' = ctx.ownsInstanceAndDevice
    let protectedContext' = ctx.protectedContext

    let options = castPtr inOptions

    ptr <- [C.block|void* {
        gr_vk_backendcontext_t in;
        in.fInstance = $(void* instancePtr');
        in.fPhysicalDevice = $(void* physicalDevice');
        in.fDevice = $(void* device');
        in.fQueue = $(void* queue');
        in.fGraphicsQueueIndex = $(uint32_t graphicsQueueIndex');
        in.fMinAPIVersion = $(uint32_t minAPIVersion');
        in.fInstanceVersion = $(uint32_t instanceVersion');
        in.fMaxAPIVersion = $(uint32_t maxAPIVersion');
        in.fExtensions = $(uint32_t extensions');
        in.fVkExtensions = $(void* vkExtensions');
        in.fFeatures = $(uint32_t features');
        in.fDeviceFeatures = $(void* deviceFeatures');
        in.fDeviceFeatures2 = $(void* deviceFeatures2');
        in.fMemoryAllocator = $(void* memoryAllocator');
        in.fGetProc = $(void* getProc');
        in.fGetProcUserData = $(void* getProcUserData');
        in.fOwnsInstanceAndDevice = $(bool ownsInstanceAndDevice');
        in.fProtectedContext = $(bool protectedContext');

        return gr_direct_context_make_vulkan_with_options(in, $(void* options));
    }|]
    pure (castPtr ptr)

-- | `sk_canvas_clear_color4f`
skCanvasClearColor4f :: Ptr SkCanvas -> SkColor4F -> IO ()
skCanvasClearColor4f inCanvas SkColor4F{r, g, b, a}  = do
    let canvas = castPtr inCanvas
    [C.block|void {
        sk_color4f_t color = {$(float r), $(float g), $(float b), $(float a)};
        sk_canvas_clear_color4f($(void* canvas), color);
    }|]

-- | `sk_canvas_draw_color4f`
skCanvasDrawColor4f :: Ptr SkCanvas -> SkColor4F -> SkBlendMode -> IO ()
skCanvasDrawColor4f inCanvas SkColor4F{r, g, b, a} (SkBlendMode blendMode) = do
    let canvas = castPtr inCanvas
    [C.block|void {
        sk_color4f_t color = {$(float r), $(float g), $(float b), $(float a)};
        sk_canvas_draw_color4f($(void* canvas), color, $(uint32_t blendMode));
    }|]

-- | Taken from include/encode/SkPngEncoder.h
defaultSkPngEncoderOptions :: SkPngEncoderOptions
defaultSkPngEncoderOptions = SkPngEncoderOptions
    { filterFlags = skPngEncoderFilterFlags'All
    , zLibLevel = 6
    , comments = nullPtr
    , iccProfile = nullPtr
    , iccProfileDescription = nullPtr
    }
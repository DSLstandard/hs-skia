module SkiaSharp.Bindings.Internal.Manual where

import qualified Language.C.Inline as C

import Foreign
import SkiaSharp.Bindings.Internal.AutoGenerated

C.include "<c/gr_context.h>"
C.include "<c/sk_bitmap.h>"
C.include "<c/sk_blender.h>"
C.include "<c/sk_canvas.h>"
C.include "<c/sk_codec.h>"
C.include "<c/sk_colorfilter.h>"
C.include "<c/sk_colorspace.h>"
C.include "<c/sk_data.h>"
C.include "<c/sk_document.h>"
C.include "<c/sk_drawable.h>"
C.include "<c/sk_font.h>"
C.include "<c/sk_general.h>"
C.include "<c/sk_graphics.h>"
C.include "<c/sk_image.h>"
C.include "<c/sk_imagefilter.h>"
C.include "<c/sk_linker.h>"
C.include "<c/sk_maskfilter.h>"
C.include "<c/sk_matrix.h>"
C.include "<c/sk_paint.h>"
C.include "<c/sk_path.h>"
C.include "<c/sk_patheffect.h>"
C.include "<c/sk_picture.h>"
C.include "<c/sk_pixmap.h>"
C.include "<c/sk_region.h>"
C.include "<c/sk_rrect.h>"
C.include "<c/sk_runtimeeffect.h>"
C.include "<c/sk_shader.h>"
C.include "<c/sk_stream.h>"
C.include "<c/sk_string.h>"
C.include "<c/sk_surface.h>"
C.include "<c/sk_svg.h>"
C.include "<c/sk_textblob.h>"
C.include "<c/sk_typeface.h>"
C.include "<c/sk_types.h>"
C.include "<c/sk_vertices.h>"
C.include "<c/skottie_animation.h>"
C.include "<c/skresources_resource_provider.h>"
C.include "<c/sksg_invalidation_controller.h>"

-- TODO: Learn how to use inline-c properly for passing C structure values.

-- | `gr_direct_context_make_direct3d`
gr_direct_context_make_direct3d :: Gr_d3d_backendcontext -> IO (Ptr Gr_direct_context)
gr_direct_context_make_direct3d ctx = do
    let adapter = castPtr ctx.fAdapter
    let device = castPtr ctx.fDevice
    let queue = castPtr ctx.fQueue
    let memoryAllocator = castPtr ctx.fMemoryAllocator
    let protectedContext = ctx.fProtectedContext

    ptr <- [C.block|void* {
        gr_d3d_backendcontext_t in;
        in.fAdapter = $(void* adapter);
        in.fDevice = $(void* device);
        in.fQueue = $(void* queue);
        in.fMemoryAllocator = $(void* memoryAllocator);
        in.fProtectedContext = $(bool protectedContext);

        return gr_direct_context_make_direct3d(in);
    }|]
    pure (castPtr ptr)

-- | `gr_direct_context_make_direct3d_with_options`
gr_direct_context_make_direct3d_with_options :: Gr_d3d_backendcontext -> Ptr Gr_context_options -> IO (Ptr Gr_direct_context)
gr_direct_context_make_direct3d_with_options ctx inOptions = do
    let adapter = castPtr ctx.fAdapter
    let device = castPtr ctx.fDevice
    let queue = castPtr ctx.fQueue
    let memoryAllocator = castPtr ctx.fMemoryAllocator
    let protectedContext = ctx.fProtectedContext

    let options = castPtr inOptions

    ptr <- [C.block|void* {
        gr_d3d_backendcontext_t in;
        in.fAdapter = $(void* adapter);
        in.fDevice = $(void* device);
        in.fQueue = $(void* queue);
        in.fMemoryAllocator = $(void* memoryAllocator);
        in.fProtectedContext = $(bool protectedContext);

        return gr_direct_context_make_direct3d_with_options(in, $(void* options));
    }|]
    pure (castPtr ptr)

-- | `gr_direct_context_make_vulkan`
gr_direct_context_make_vulkan :: Gr_vk_backendcontext -> IO (Ptr Gr_direct_context)
gr_direct_context_make_vulkan ctx = do
    let instancePtr = castPtr ctx.fInstance
    let physicalDevice = castPtr ctx.fPhysicalDevice
    let device = castPtr ctx.fDevice
    let queue = castPtr ctx.fQueue
    let graphicsQueueIndex = ctx.fGraphicsQueueIndex
    let minAPIVersion = ctx.fMinAPIVersion
    let instanceVersion = ctx.fInstanceVersion
    let maxAPIVersion = ctx.fMaxAPIVersion
    let extensions = ctx.fExtensions
    let vkExtensions = castPtr ctx.fVkExtensions
    let features = ctx.fFeatures
    let deviceFeatures = castPtr ctx.fDeviceFeatures
    let deviceFeatures2 = castPtr ctx.fDeviceFeatures2
    let memoryAllocator = castPtr ctx.fMemoryAllocator
    let getProc :: Ptr () = castFunPtrToPtr ctx.fGetProc
    let getProcUserData = castPtr ctx.fGetProcUserData
    let ownsInstanceAndDevice = ctx.fOwnsInstanceAndDevice
    let protectedContext = ctx.fProtectedContext

    ptr <- [C.block|void* {
        gr_vk_backendcontext_t in;
        in.fInstance = $(void* instancePtr);
        in.fPhysicalDevice = $(void* physicalDevice);
        in.fDevice = $(void* device);
        in.fQueue = $(void* queue);
        in.fGraphicsQueueIndex = $(uint32_t graphicsQueueIndex);
        in.fMinAPIVersion = $(uint32_t minAPIVersion);
        in.fInstanceVersion = $(uint32_t instanceVersion);
        in.fMaxAPIVersion = $(uint32_t maxAPIVersion);
        in.fExtensions = $(uint32_t extensions);
        in.fVkExtensions = $(void* vkExtensions);
        in.fFeatures = $(uint32_t features);
        in.fDeviceFeatures = $(void* deviceFeatures);
        in.fDeviceFeatures2 = $(void* deviceFeatures2);
        in.fMemoryAllocator = $(void* memoryAllocator);
        in.fGetProc = $(void* getProc);
        in.fGetProcUserData = $(void* getProcUserData);
        in.fOwnsInstanceAndDevice = $(bool ownsInstanceAndDevice);
        in.fProtectedContext = $(bool protectedContext);

        return gr_direct_context_make_vulkan(in);
    }|]
    pure (castPtr ptr)

-- | `gr_direct_context_make_vulkan_with_options`
gr_direct_context_make_vulkan_with_options :: Gr_vk_backendcontext -> Ptr Gr_context_options -> IO (Ptr Gr_direct_context)
gr_direct_context_make_vulkan_with_options ctx inOptions = do
    let instancePtr = castPtr ctx.fInstance
    let physicalDevice = castPtr ctx.fPhysicalDevice
    let device = castPtr ctx.fDevice
    let queue = castPtr ctx.fQueue
    let graphicsQueueIndex = ctx.fGraphicsQueueIndex
    let minAPIVersion = ctx.fMinAPIVersion
    let instanceVersion = ctx.fInstanceVersion
    let maxAPIVersion = ctx.fMaxAPIVersion
    let extensions = ctx.fExtensions
    let vkExtensions = castPtr ctx.fVkExtensions
    let features = ctx.fFeatures
    let deviceFeatures = castPtr ctx.fDeviceFeatures
    let deviceFeatures2 = castPtr ctx.fDeviceFeatures2
    let memoryAllocator = castPtr ctx.fMemoryAllocator
    let getProc :: Ptr () = castFunPtrToPtr ctx.fGetProc
    let getProcUserData = castPtr ctx.fGetProcUserData
    let ownsInstanceAndDevice = ctx.fOwnsInstanceAndDevice
    let protectedContext = ctx.fProtectedContext

    let options = castPtr inOptions

    ptr <- [C.block|void* {
        gr_vk_backendcontext_t in;
        in.fInstance = $(void* instancePtr);
        in.fPhysicalDevice = $(void* physicalDevice);
        in.fDevice = $(void* device);
        in.fQueue = $(void* queue);
        in.fGraphicsQueueIndex = $(uint32_t graphicsQueueIndex);
        in.fMinAPIVersion = $(uint32_t minAPIVersion);
        in.fInstanceVersion = $(uint32_t instanceVersion);
        in.fMaxAPIVersion = $(uint32_t maxAPIVersion);
        in.fExtensions = $(uint32_t extensions);
        in.fVkExtensions = $(void* vkExtensions);
        in.fFeatures = $(uint32_t features);
        in.fDeviceFeatures = $(void* deviceFeatures);
        in.fDeviceFeatures2 = $(void* deviceFeatures2);
        in.fMemoryAllocator = $(void* memoryAllocator);
        in.fGetProc = $(void* getProc);
        in.fGetProcUserData = $(void* getProcUserData);
        in.fOwnsInstanceAndDevice = $(bool ownsInstanceAndDevice);
        in.fProtectedContext = $(bool protectedContext);

        return gr_direct_context_make_vulkan_with_options(in, $(void* options));
    }|]
    pure (castPtr ptr)

-- | `sk_canvas_clear_color4f`
sk_canvas_clear_color4f :: Ptr Sk_canvas -> Sk_color4f -> IO ()
sk_canvas_clear_color4f inCanvas Sk_color4f{fR, fG, fB, fA}  = do
    let canvas = castPtr inCanvas
    [C.block|void {
        sk_color4f_t color = {$(float fR), $(float fG), $(float fB), $(float fA)};
        sk_canvas_clear_color4f($(void* canvas), color);
    }|]

-- | `sk_canvas_draw_color4f`
sk_canvas_draw_color4f :: Ptr Sk_canvas -> Sk_color4f -> Sk_blendmode -> IO ()
sk_canvas_draw_color4f inCanvas Sk_color4f{fR, fG, fB, fA} (Sk_blendmode blendMode) = do
    let canvas = castPtr inCanvas
    [C.block|void {
        sk_color4f_t color = {$(float fR), $(float fG), $(float fB), $(float fA)};
        sk_canvas_draw_color4f($(void* canvas), color, $(uint32_t blendMode));
    }|]

-- | Taken from include/encode/SkPngEncoder.h
defaultSkPngEncoderOptions :: Sk_pngencoder_options
defaultSkPngEncoderOptions = Sk_pngencoder_options
    { fFilterFlags = sk_pngencoder_filterflags'ALL_SK_PNGENCODER_FILTER_FLAGS
    , fZLibLevel = 6
    , fComments = nullPtr
    , fICCProfile = nullPtr
    , fICCProfileDescription = nullPtr
    }